// define the shader version (this is required)
#version 420 core

#define hi 
#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#define hi 
#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#define hi 
#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#define hi 
#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#define hi 
#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}// define the shader version (this is required)
#version 420 core

#include "inc/common.glsl"


// Attributes - input to this shasder stage (constant as far as the code is concerned)
in vec3 POSITION;
in vec4 COLOR;       // NEW - GLSL will use a Vector4 for this;
in vec2 UV;          // new


//pass variables or "varying" variables
// These are variables output from this stage for use by the next stage
// These are called "varying" because for a triangle, we'll only output 3, and 
// the Raster stage may output hundreds of pixels, each a blended value
// of the initial 3, hence - they "vary"
out vec2 passUV; 
out vec4 passColor;  // NEW - to use it in the pixel stage, we must pass it.

// Entry point - required.  What does this stage do?
void main( void )
{
   // multiply it through - for now, local_pos
   // is being treated as view space position
   // this will be updated later once we introduce the other matrices
    vec4 local_pos = vec4( POSITION, 1 ); 
    vec4 clip_pos =  PROJECTION * (VIEW * local_pos); 
   
    passColor = COLOR; // pass it on. 
    passUV = UV; // we have to set our outs.

    gl_Position = clip_pos;  // changed
}#version 420 core

// create a uniform for our sampler2D.
// layout binding = 0 is us binding it to texture slot 0.  
layout(binding = 0) uniform sampler2D gTexDiffuse;


// We match the name and type of the previous stages out
in vec4 passColor; // NEW, passed color
in vec2 passUV; 


// Outputs
//out vec4 outColor; 

// Entry Point
void main( void )
{
   // sample (gather) our texel colour for this UV
   vec4 diffuse = texture( gTexDiffuse, passUV ); 
   outColor = diffuse * passColor;
}#version 420 core

// create a uniform for our sampler2D.
// layout binding = 0 is us binding it to texture slot 0.  
layout(binding = 0) uniform sampler2D gTexDiffuse;


// We match the name and type of the previous stages out
in vec4 passColor; // NEW, passed color
in vec2 passUV; 


// Outputs
//out vec4 outColor; 

// Entry Point
void main( void )
{
   // sample (gather) our texel colour for this UV
   vec4 diffuse = texture( gTexDiffuse, passUV ); 
   outColor = diffuse * passColor;
}#version 420 core

// create a uniform for our sampler2D.
// layout binding = 0 is us binding it to texture slot 0.  
layout(binding = 0) uniform sampler2D gTexDiffuse;


// We match the name and type of the previous stages out
in vec4 passColor; // NEW, passed color
in vec2 passUV; 


// Outputs
ot vec4 outColor; 

// Entry Point
void main( void )
{
   // sample (gather) our texel colour for this UV
   vec4 diffuse = texture( gTexDiffuse, passUV ); 
   outColor = diffuse * passColor;
}#version 420 core

// create a uniform for our sampler2D.
// layout binding = 0 is us binding it to texture slot 0.  
layout(binding = 0) uniform sampler2D gTexDiffuse;


// We match the name and type of the previous stages out
in vec4 passColor; // NEW, passed color
in vec2 passUV; 


// Outputs
ot vec4 outColor; 

// Entry Point
void main( void )
{
   // sample (gather) our texel colour for this UV
   vec4 diffuse = texture( gTexDiffuse, passUV ); 
   outColor = diffuse * passColor;
}#version 420 core


// Suggest always manually setting bindings - again, consitancy with 
// other rendering APIs and well as you can make assumptions in your
// engine without having to query
layout(binding = 8) uniform samplerCube gTexSky;
//layout(binding = 0) uniform sampler2D gTexDiffuse;

//in vec3 passWorldPosition; 
in vec4 passColor; 
in vec2 passUV; 

out vec4 outColor; 

void main( void )
{
    // sample (gather) our texel colour for this UV
   vec4 diffuse = texture( gTexDiffuse, passUV ); 
   outColor = diffuse * passColor;
}
#version 420 core


// Suggest always manually setting bindings - again, consitancy with 
// other rendering APIs and well as you can make assumptions in your
// engine without having to query
layout(binding = 8) uniform samplerCube gTexSky;
//layout(binding = 0) uniform sampler2D gTexDiffuse;

in vec3 passWorldPosition; 
in vec4 passColor; 
//in vec2 passUV; 

out vec4 outColor; 

void main( void )
{
    // sample (gather) our texel colour for this UV
   //vec4 diffuse = texture( gTexSky, passUV ); 
   //outColor = diffuse * passColor;

   vec3 normal = normalize(passWorldPosition); 
   vec4 tex_color = texture( gTexSky, normal ); 

   //outColor = tex_color * passColor;
   outColor = vec4(1,0,0,1)
}
#version 420 core


// Suggest always manually setting bindings - again, consitancy with 
// other rendering APIs and well as you can make assumptions in your
// engine without having to query
layout(binding = 8) uniform samplerCube gTexSky;
//layout(binding = 0) uniform sampler2D gTexDiffuse;

in vec3 passWorldPosition; 
in vec4 passColor; 
//in vec2 passUV; 

out vec4 outColor; 

void main( void )
{
    // sample (gather) our texel colour for this UV
   //vec4 diffuse = texture( gTexSky, passUV ); 
   //outColor = diffuse * passColor;

   vec3 normal = normalize(passWorldPosition); 
   vec4 tex_color = texture( gTexSky, normal ); 
    outColor = vec4((normal + vec3(1)) * .5f, 1f);
   //outColor = tex_color * passColor;
   //outColor = tex_color;
   outColr = vec4(1.f,0.f,0.f,1.f);
}
#version 420 core


// Suggest always manually setting bindings - again, consitancy with 
// other rendering APIs and well as you can make assumptions in your
// engine without having to query
layout(binding = 8) uniform samplerCube gTexSky;
//layout(binding = 0) uniform sampler2D gTexDiffuse;

in vec3 passWorldPosition; 
in vec4 passColor; 
//in vec2 passUV; 

out vec4 outColor; 

void main( void )
{
    // sample (gather) our texel colour for this UV
   //vec4 diffuse = texture( gTexSky, passUV ); 
   //outColor = diffuse * passColor;

   vec3 normal = normalize(passWorldPosition); 
   vec4 tex_color = texture( gTexSky, normal ); 
    outColor = vec4((normal + vec3(1)) * .5f, 1f);
   //outColor = tex_color * passColor;
   //outColor = tex_color;
   outColr = vec4(1.f,0.f,0.f,1.f);
}
#version 420 core


// Suggest always manually setting bindings - again, consitancy with 
// other rendering APIs and well as you can make assumptions in your
// engine without having to query
layout(binding = 8) uniform samplerCube gTexSky;
//layout(binding = 0) uniform sampler2D gTexDiffuse;

in vec3 passWorldPosition; 
in vec4 passColor; 
//in vec2 passUV; 

out vec4 outColor; 

void main( void )
{
    // sample (gather) our texel colour for this UV
   //vec4 diffuse = texture( gTexSky, passUV ); 
   //outColor = diffuse * passColor;

   vec3 normal = normalize(passWorldPosition); 
   vec4 tex_color = texture( gTexSky, normal ); 
    outColor = vec4((normal + vec3(1)) * .5f, 1f);
   //outColor = tex_color * passColor;
   //outColor = tex_color;
   outColr = vec4(1.f,0.f,0.f,1.f);
}
